= diamond

{MIDI arpeggiator}[http://en.wikipedia.org/wiki/Arpeggiator#Arpeggiator] in Ruby

{pic}[http://images.treetrouble.net/images/diamond.jpg]

== Features

* Classic arpeggiator functions
* Uses {unimidi}[http://github.com/arirusso/unimidi] for cross-platform compatibility
* Run as a background thread for {live coding}[http://en.wikipedia.org/wiki/Live_coding]
* Sync to and from MIDI clock
* Sync between multiple Diamond instances as well as other {Topaz Tempo}[http://github.com/arirusso/topaz] objects
* {Preset}[http://github.com/arirusso/diamond/blob/master/lib/diamond/patterns.rb] and {user-definable}[http://github.com/arirusso/diamond/blob/master/examples/live_coding.rb] pattern algorithms 

== Installation

  gem install diamond
  
== Gem dependencies

* {midi-eye}[http://github.com/arirusso/midi-eye]
* {midi-message}[http://github.com/arirusso/midi-message]
* {topaz}[http://github.com/arirusso/topaz]
* {unimidi}[http://github.com/arirusso/unimidi]

these will install automatically with the gem

== Usage

  require "diamond"

First, select a MIDI output using {unimidi}[http://github.com/arirusso/unimidi].  ({read more about that here}[http://github.com/arirusso/unimidi/blob/master/examples/select_a_device.rb])

  @output = UniMIDI::Output.first.open

The Arpeggiator has a number of {optional parameters}[http://tx81z.blogspot.com/].  For this example, here is a very straightforward setup

  opts = { 
    :gate => 90, 
    :range => 4, 
    :interval => 7,
    :midi => @output,
    :offset => 1,
    :pattern => Diamond::Pattern["UpDown"],    
    :rate => 8
  }

Create an Arpeggiator object, passing in a tempo value and the options above. In this case the tempo will be 138 BPM

  arp = Diamond::Arpeggiator.new(138, opts)
 
If you'd like to sync to MIDI clock instead of internally generating tempo, pass in a unimidi input instead of a numeric tempo ({see example}[http://github.com/arirusso/diamond/blob/master/examples/midi_sync.rb])

Of course, the Arpeggiator needs notes to work with.  As you might expect, it is easy to use a MIDI input for that. ({see example}[http://github.com/arirusso/diamond/blob/master/examples/midi_input.rb]).  However, for the sake of simplicity here is a three note chord created with Ruby code

  include MIDIMessage

  chord = [
    NoteOn["C4"].new(0, 100),
    NoteOn["E4"].new(0, 100),
    NoteOn["G4"].new(0, 100)
  ]

Use Arpeggiator#add and Arpeggiator#remove to give or take them away

  arp.add(chord)

If you are working in irb, you can start the arpeggiator in a background thread by passing an option :background =&gt; true to Arpeggiator#start.  That will allow you to live code, sync it other arpeggiators, or just run another foreground process. 

  arp.start(:background =&gt; true)

All of the [arpeggiator options] can be controlled on the on the fly

  arp.rate = 16
  arp.gate = 20
  arp.remove(chord.last)

Here is a screencast of Diamond being live coded.  

Click here to see a blog post that goes further in-depth with live coding

== Other Documentation

* {examples}[http://github.com/arirusso/diamond/tree/master/examples]
* {rdoc}[http://rdoc.info/gems/diamond] 

== Author

* {Ari Russo}[http://github.com/arirusso] <ari.russo at gmail.com>

== License

Apache 2.0, See the file LICENSE

Copyright (c) 2011 Ari Russo
